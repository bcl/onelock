
leds.elf:     file format elf32-msp430

SYMBOL TABLE:
00001100 l    d  .text	00000000 
00000200 l    d  .data	00000000 
00000c00 l    d  .bootloader	00000000 
00001000 l    d  .infomem	00000000 
00001000 l    d  .infomemnobits	00000000 
00000200 l    d  .bss	00000000 
00000208 l    d  .noinit	00000000 
0000ffe0 l    d  .vectors	00000000 
00000000 l    d  .stab	00000000 
00000000 l    d  .stabstr	00000000 
00000000 l    d  *ABS*	00000000 
00000000 l    d  *ABS*	00000000 
00000000 l    d  *ABS*	00000000 
00000000 l    df *ABS*	00000000 <command line>
00000000 l    df *ABS*	00000000 <built-in>
00000000 l    df *ABS*	00000000 gcrt0.S
00000000 l    df *ABS*	00000000 gcrt0.S
00000000 l    df *ABS*	00000000 <command line>
00000000 l    df *ABS*	00000000 <built-in>
00000000 l    df *ABS*	00000000 gcrt0.S
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TAIV
00000160 l       *ABS*	00000000 TACTL
00000162 l       *ABS*	00000000 TACCTL0
00000164 l       *ABS*	00000000 TACCTL1
00000166 l       *ABS*	00000000 TACCTL2
00000170 l       *ABS*	00000000 TAR
00000172 l       *ABS*	00000000 TACCR0
00000174 l       *ABS*	00000000 TACCR1
00000176 l       *ABS*	00000000 TACCR2
00000162 l       *ABS*	00000000 CCTL0
00000164 l       *ABS*	00000000 CCTL1
00000166 l       *ABS*	00000000 CCTL2
00000172 l       *ABS*	00000000 CCR0
00000174 l       *ABS*	00000000 CCR1
00000176 l       *ABS*	00000000 CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000190 l       *ABS*	00000000 TBR
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
00000000 l    df *ABS*	00000000 main.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001254 l       .text	00000000 Letext
00000000 l    df *ABS*	00000000 interrupts.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
000012f6 l       .text	00000000 Letext
00000000 l    df *ABS*	00000000 dco.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001380 l       .text	00000000 Letext
00000000 l    df *ABS*	00000000 onewire.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
000014ce l       .text	00000000 Letext
00000000 l    df *ABS*	00000000 <command line>
00000000 l    df *ABS*	00000000 <built-in>
000014d2 l       .text	00000000 __stop_progLoop
00001120  w      .text	00000000 _clear_bss_init__
00000200 g     O .bss	00000002 VZC_2delta
00001390 g     F .text	00000040 ow_reset
000012f4 g     F .text	00000002 INT_nmi
000014d6 g       .text	00000000 _etext
000012be g     F .text	00000002 INT_uart1rx
000014ce g       .text	00000000 __stop_progExec__
0000113a g       .text	00000000 _unexpected_1_
0000113a  w      .text	00000000 vector_ffe0
0000117c g     F .text	00000026 InitDCO
00000206 g     O .bss	00000002 VZC_LastCap
000012e4 g     F .text	00000002 INT_timera0
00000202 g     O .bss	00000001 Status
000012f2 g     F .text	00000002 INT_timerb0
000012e4 g       .text	00000000 vector_ffec
000012e8 g       .text	00000000 vector_fff0
00001430 g     F .text	0000005e ow_read
000012ba g     F .text	00000002 INT_port2
0000113a g       .text	00000000 __dtors_end
00000208 g       .bss	00000000 __bss_end
000012f4 g       .text	00000000 vector_fffc
000012e6 g     F .text	00000002 INT_adc
000012bc g       .text	00000000 vector_ffe4
000012bc g     F .text	00000002 INT_uart1tx
000012ee g     F .text	00000002 INT_compa
0000ffe0 g     O .vectors	00000020 InterruptVectors
000013d0 g     F .text	00000060 ow_write
000012c0 g     F .text	00000002 INT_port1
00000204 g     O .bss	00000002 Rsel
00001136  w      .text	00000000 _end_of_init__
000012f0 g     F .text	00000002 INT_timerb1
000012ea g     F .text	00000002 INT_uart0rx
000012ba g       .text	00000000 vector_ffe2
000012c0 g       .text	00000000 vector_ffe8
0000113e  w      .text	00000000 _unexpected_
000012f2 g       .text	00000000 vector_fffa
00001100 g       .text	00000000 _reset_vector__
0000113a g       .text	00000000 __ctors_start
0000116e g     F .text	0000000e InitOSC
00000200 g       .bss	00000000 __bss_start
000012e6 g       .text	00000000 vector_ffee
000012ec g       .text	00000000 vector_fff4
000011a2 g     F .text	000000b2 main
00001254 g     F .text	00000066 InitIRQ
000012f0 g       .text	00000000 vector_fff8
000012ea g       .text	00000000 vector_fff2
00010000 g       .vectors	00000000 _vectors_end
000012be g       .text	00000000 vector_ffe6
00001140 g     F .text	00000012 delay
000012c2 g     F .text	00000022 INT_timera1
00001152 g     F .text	0000001c InitPorts
000012f6 g     F .text	00000032 Rsel_set
0000148e g     F .text	00000040 ow_read_rom
0000113a g       .text	00000000 __dtors_start
0000113a g       .text	00000000 __ctors_end
00000a00 g       *ABS*	00000000 __stack
000012ec g     F .text	00000002 INT_wdt
00000200 g       .data	00000000 _edata
00000208 g       .noinit	00000000 _end
00001328 g     F .text	00000058 dco_step
000012ee g       .text	00000000 vector_fff6
00001380 g     F .text	00000010 ow_delay
00001106  w      .text	00000000 _copy_data_init__
000012e8 g     F .text	00000002 INT_uart0tx
00000200 g       .data	00000000 __data_start
000012c2 g       .text	00000000 vector_ffea


Disassembly of section .text:

00001100 <_reset_vector__>:
    1100:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1104:	20 01 

00001106 <_copy_data_init__>:
    1106:	3f 40 d6 14 	mov	#5334,	r15	;#0x14d6
    110a:	3e 40 00 02 	mov	#512,	r14	;#0x0200
    110e:	3d 40 00 02 	mov	#512,	r13	;#0x0200
    1112:	0d 9e       	cmp	r14,	r13	;
    1114:	05 24       	jz	$+12     	;abs 0x1120
    1116:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;
    111a:	1e 53       	inc	r14		;
    111c:	0e 9d       	cmp	r13,	r14	;
    111e:	fb 2b       	jnc	$-8      	;abs 0x1116

00001120 <_clear_bss_init__>:
    1120:	3f 40 00 02 	mov	#512,	r15	;#0x0200
    1124:	3d 40 08 02 	mov	#520,	r13	;#0x0208
    1128:	0d 9f       	cmp	r15,	r13	;
    112a:	05 24       	jz	$+12     	;abs 0x1136
    112c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00
    1130:	1f 53       	inc	r15		;
    1132:	0f 9d       	cmp	r13,	r15	;
    1134:	fb 2b       	jnc	$-8      	;abs 0x112c

00001136 <_end_of_init__>:
    1136:	30 40 a2 11 	br	#0x11a2		;

0000113a <__ctors_end>:
    113a:	30 40 3e 11 	br	#0x113e		;

0000113e <_unexpected_>:
    113e:	00 13       	reti			

00001140 <delay>:
Delay function.
   ----------------------------------------------------------------------- */
void delay(unsigned int d) {
   int i;
   for (i = 0; i<d; i++) {
    1140:	0e 43       	clr	r14		;
    1142:	0e 9f       	cmp	r15,	r14	;
    1144:	05 2c       	jc	$+12     	;abs 0x1150
      nop();
    1146:	03 43       	nop			
      nop();
    1148:	03 43       	nop			
    114a:	1e 53       	inc	r14		;
    114c:	0e 9f       	cmp	r15,	r14	;
    114e:	fb 2b       	jnc	$-8      	;abs 0x1146
   }
}
    1150:	30 41       	ret			

00001152 <InitPorts>:


void InitPorts( void )
{
  /* Initialize the ports */
  P1OUT  = P1OUT_INIT;                //Init output data of port1
    1152:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
  P2OUT  = P2OUT_INIT;                //Init output data of port2
    1156:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00

  P1SEL  = P1SEL_INIT;                //Select port or module -function on port1
    115a:	c2 43 26 00 	mov.b	#0,	&0x0026	;r3 As==00
  P2SEL  = P2SEL_INIT;                //Select port or module -function on port2
    115e:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00

  P1DIR  = P1DIR_INIT;                //Init port direction register of port1
    1162:	f2 40 fd ff 	mov.b	#-3,	&0x0022	;#0xfffd
    1166:	22 00 
  P2DIR  = P2DIR_INIT;                //Init port direction register of port2
    1168:	f2 43 2a 00 	mov.b	#-1,	&0x002a	;r3 As==11
}
    116c:	30 41       	ret			

0000116e <InitOSC>:

void InitOSC( void )
{
    /* Clear OSC Fault */
    IE1 = 0x00;
    116e:	c2 43 00 00 	mov.b	#0,	&0x0000	;r3 As==00
    IFG1 = 0x00;
    1172:	c2 43 02 00 	mov.b	#0,	&0x0002	;r3 As==00
    
    /* Select DCO/1 as MCLK */
    BCSCTL2 = 0x00;
    1176:	c2 43 58 00 	mov.b	#0,	&0x0058	;r3 As==00
}
    117a:	30 41       	ret			

0000117c <InitDCO>:

void InitDCO( void )
{
    /* Setup the DCO frequency */
    Rsel = RSEL_NOM;
    117c:	a2 42 04 02 	mov	#4,	&0x0204	;r2 As==10
    Rsel_set( Rsel );
    1180:	2f 42       	mov	#4,	r15	;r2 As==10
    1182:	b0 12 f6 12 	call	#4854		;#0x12f6
    
    /* Setup for ACLK/8 */
    BCSCTL1 |= DIVA_DIV8;
    1186:	f2 d0 30 00 	bis.b	#48,	&0x0057	;#0x0030
    118a:	57 00 

    /* Diagnostic */
    /* Output SMCLK on P1.4 pin 16 f149 */
    P1SEL |= 0x10;
    118c:	f2 d0 10 00 	bis.b	#16,	&0x0026	;#0x0010
    1190:	26 00 
    P1DIR |= 0x10;
    1192:	f2 d0 10 00 	bis.b	#16,	&0x0022	;#0x0010
    1196:	22 00 
    
    /* Output ACLK on P2.0 pin 20 f149 */
    P2SEL |= 0x01;
    1198:	d2 d3 2e 00 	bis.b	#1,	&0x002e	;r3 As==01
    P2DIR |= 0x01;
    119c:	d2 d3 2a 00 	bis.b	#1,	&0x002a	;r3 As==01
}
    11a0:	30 41       	ret			

000011a2 <main>:



/* -----------------------------------------------------------------------
   Main function with a blinking LED
   ----------------------------------------------------------------------- */
int main(void)
{
    11a2:	31 40 f8 09 	mov	#2552,	r1	;#0x09f8
    short i;
    unsigned int success;
    short adj_timer;
    unsigned char sn[8];		/* 1-wire serial number 	*/
    
    /* Watchdog disabled */
    WDTCTL = WDTPW|WDTHOLD;
    11a6:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    11aa:	20 01 

    Status = 0;
    11ac:	c2 43 02 02 	mov.b	#0,	&0x0202	;r3 As==00

    InitPorts();
    11b0:	b0 12 52 11 	call	#4434		;#0x1152
    InitOSC();
    11b4:	b0 12 6e 11 	call	#4462		;#0x116e
    InitDCO();
    11b8:	b0 12 7c 11 	call	#4476		;#0x117c
    InitIRQ();
    11bc:	b0 12 54 12 	call	#4692		;#0x1254

    /* Turn on power to 1-wire pullup */
    P1OUT |= 0x04;
    11c0:	e2 d2 21 00 	bis.b	#4,	&0x0021	;r2 As==10

    P1OUT &= ~0x01;
    11c4:	d2 c3 21 00 	bic.b	#1,	&0x0021	;r3 As==01
    adj_timer = DCO_ADJ_TIME;
    11c8:	29 43       	mov	#2,	r9	;r3 As==10
    11ca:	36 40 28 13 	mov	#4904,	r6	;#0x1328
    11ce:	38 40 90 13 	mov	#5008,	r8	;#0x1390
    11d2:	37 40 8e 14 	mov	#5262,	r7	;#0x148e
    11d6:	35 40 40 11 	mov	#4416,	r5	;#0x1140
    while (1) {                         //main loop, never ends...
      if( Status & TASK_OVR )
    11da:	5f 42 02 02 	mov.b	&0x0202,r15	;0x0202
    11de:	1f f3       	and	#1,	r15	;r3 As==01
    11e0:	04 24       	jz	$+10     	;abs 0x11ea
      {
        if( --adj_timer == 0 )
    11e2:	39 53       	add	#-1,	r9	;r3 As==11
    11e4:	2f 24       	jz	$+96     	;abs 0x1244
        {
          dco_step();
          adj_timer = DCO_ADJ_TIME;
          P1OUT &= ~0x01;
        }
        Status &= ~TASK_OVR; 
    11e6:	d2 c3 02 02 	bic.b	#1,	&0x0202	;r3 As==01
      }

      if( !(P1IN & 0x02) )
    11ea:	5f 42 20 00 	mov.b	&0x0020,r15	;0x0020
    11ee:	2f f3       	and	#2,	r15	;r3 As==10
    11f0:	f4 23       	jnz	$-22     	;abs 0x11da
      {
        success = 0;
    11f2:	0a 4f       	mov	r15,	r10	;
        for(i=0;i<8;i++)
    11f4:	0b 4f       	mov	r15,	r11	;
    11f6:	3e 40 07 00 	mov	#7,	r14	;#0x0007
        {
          sn[i] = 0;
    11fa:	0f 41       	mov	r1,	r15	;
    11fc:	0f 5b       	add	r11,	r15	;
    11fe:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00
    1202:	1b 53       	inc	r11		;
    1204:	0e 9b       	cmp	r11,	r14	;
    1206:	f9 37       	jge	$-12     	;abs 0x11fa
        }
        for(i=0;(i<5) && !success;i++)
    1208:	0b 43       	clr	r11		;
    120a:	0a 9b       	cmp	r11,	r10	;
    120c:	e6 23       	jnz	$-50     	;abs 0x11da
        {
          if( ow_reset() )
    120e:	88 12       	call	r8		;
    1210:	0f 93       	cmp	#0,	r15	;r3 As==00
    1212:	07 20       	jnz	$+16     	;abs 0x1222
    1214:	1b 53       	inc	r11		;
    1216:	3b 90 05 00 	cmp	#5,	r11	;#0x0005
    121a:	df 37       	jge	$-64     	;abs 0x11da
    121c:	0a 93       	cmp	#0,	r10	;r3 As==00
    121e:	f7 27       	jz	$-16     	;abs 0x120e
    1220:	dc 3f       	jmp	$-70     	;abs 0x11da
          {
            /* Turn on the LED */
//            P1OUT |= 0x01;
              
            /* Go Read the 1-wire serial number */
            ow_read_rom( sn );
    1222:	0f 41       	mov	r1,	r15	;
    1224:	87 12       	call	r7		;
 
 
            if( sn[0] == 0x21 )
    1226:	f1 90 21 00 	cmp.b	#33,	0(r1)	;#0x0021
    122a:	00 00 
    122c:	f3 23       	jnz	$-24     	;abs 0x1214
            {
              /* Turn on the LED */
              P1OUT |= 0x01;
    122e:	d2 d3 21 00 	bis.b	#1,	&0x0021	;r3 As==01
 
              /* Check checksum */
   
              /* Check against the access list */
                
              /* Unlock the lock */
              P1OUT |= 0x08;
    1232:	f2 d2 21 00 	bis.b	#8,	&0x0021	;r2 As==11
              delay( 0x4000 );
    1236:	3f 40 00 40 	mov	#16384,	r15	;#0x4000
    123a:	85 12       	call	r5		;
              P1OUT &= ~0x08;
    123c:	f2 c2 21 00 	bic.b	#8,	&0x0021	;r2 As==11
              
              success = 1;
    1240:	1a 43       	mov	#1,	r10	;r3 As==01
    1242:	e8 3f       	jmp	$-46     	;abs 0x1214
    1244:	86 12       	call	r6		;
    1246:	29 43       	mov	#2,	r9	;r3 As==10
    1248:	d2 c3 21 00 	bic.b	#1,	&0x0021	;r3 As==01
    124c:	cc 3f       	jmp	$-102    	;abs 0x11e6
            }
          } /* presence */
        } /* for loop */
      }
    }
}
    124e:	31 52       	add	#8,	r1	;r2 As==11
    1250:	30 40 ce 14 	br	#0x14ce		;

00001254 <InitIRQ>:
{
  short i;
  
  /* Setup Timer A0 run off MCLK /1, continuous up count, start */
  TACTL = TASSEL_SMCLK | TACLR;
    1254:	b2 40 04 02 	mov	#516,	&0x0160	;#0x0204
    1258:	60 01 
  TACTL |= MC_CONT;
    125a:	b2 d0 20 00 	bis	#32,	&0x0160	;#0x0020
    125e:	60 01 
  
  /* Setup CCR2 */
  CCTL2 = CM_POS|CCIS_1|SCS|CAP|OUTMOD_SET;
    1260:	b2 40 20 59 	mov	#22816,	&0x0166	;#0x5920
    1264:	66 01 

  /* Delay a bit for ACLK to settle */
  for (i = 0; i<0x1000; i++)
    1266:	3f 40 00 10 	mov	#4096,	r15	;#0x1000
  {
    nop();
    126a:	03 43       	nop			
    126c:	03 43       	nop			
    126e:	03 43       	nop			
    1270:	03 43       	nop			
    1272:	03 43       	nop			
    1274:	03 43       	nop			
    1276:	03 43       	nop			
    1278:	03 43       	nop			
    127a:	03 43       	nop			
    127c:	03 43       	nop			
    127e:	03 43       	nop			
    1280:	03 43       	nop			
    1282:	03 43       	nop			
    1284:	03 43       	nop			
    1286:	03 43       	nop			
    1288:	03 43       	nop			
    128a:	03 43       	nop			
    128c:	03 43       	nop			
    128e:	03 43       	nop			
    1290:	03 43       	nop			
    1292:	03 43       	nop			
    1294:	03 43       	nop			
    1296:	03 43       	nop			
    1298:	03 43       	nop			
    129a:	03 43       	nop			
    129c:	03 43       	nop			
    129e:	03 43       	nop			
    12a0:	03 43       	nop			
    12a2:	03 43       	nop			
    12a4:	03 43       	nop			
    12a6:	03 43       	nop			
    12a8:	03 43       	nop			
    12aa:	3f 50 e0 ff 	add	#-32,	r15	;#0xffe0
    12ae:	dd 23       	jnz	$-68     	;abs 0x126a
  }
  /* Enable CCTL2 interrupt */
  CCTL2 |= CCIE;
    12b0:	b2 d0 10 00 	bis	#16,	&0x0166	;#0x0010
    12b4:	66 01 

  _EINT();
    12b6:	32 d2       	eint			
}
    12b8:	30 41       	ret			

000012ba <INT_port2>:




interrupt (PORT2_VECTOR) INT_port2( void )
{
    12ba:	00 13       	reti			

000012bc <INT_uart1tx>:
}

interrupt (UART1TX_VECTOR) INT_uart1tx( void )
{
    12bc:	00 13       	reti			

000012be <INT_uart1rx>:
}

interrupt (UART1RX_VECTOR) INT_uart1rx( void )
{
    12be:	00 13       	reti			

000012c0 <INT_port1>:
}

interrupt (PORT1_VECTOR) INT_port1( void )
{
    12c0:	00 13       	reti			

000012c2 <INT_timera1>:
} 

/* -----------------------------------------------------------------------
   Measure the 1/2 period of the 32.768KHz xtal
   ----------------------------------------------------------------------- */
interrupt (TIMERA1_VECTOR) INT_timera1( void )
{
    12c2:	0f 12       	push	r15		;
  if( TAIV == 0x04 )
    12c4:	a2 92 2e 01 	cmp	#4,	&0x012e	;r2 As==10
    12c8:	0b 20       	jnz	$+24     	;abs 0x12e0
  {
    /* CCR2 Interrupt */
    
    /* Measure the 32.768KHz period */
    VZC_2delta = CCR2 - VZC_LastCap;
    12ca:	1f 42 76 01 	mov	&0x0176,r15	;0x0176
    12ce:	1f 82 06 02 	sub	&0x0206,r15	;0x0206
    12d2:	82 4f 00 02 	mov	r15,	&0x0200	;
    VZC_LastCap = CCR2;
    12d6:	92 42 76 01 	mov	&0x0176,&0x0206	;0x0176
    12da:	06 02 
    Status |= TASK_OVR;
    12dc:	92 d3 02 02 	bis	#1,	&0x0202	;r3 As==01
  }
}
    12e0:	3f 41       	pop	r15		;
    12e2:	00 13       	reti			

000012e4 <INT_timera0>:

interrupt (TIMERA0_VECTOR) INT_timera0( void )
{
    12e4:	00 13       	reti			

000012e6 <INT_adc>:
}

interrupt (ADC_VECTOR) INT_adc( void )
{
    12e6:	00 13       	reti			

000012e8 <INT_uart0tx>:
}

interrupt (UART0TX_VECTOR) INT_uart0tx( void )
{
    12e8:	00 13       	reti			

000012ea <INT_uart0rx>:
}

interrupt (UART0RX_VECTOR) INT_uart0rx( void )
{
    12ea:	00 13       	reti			

000012ec <INT_wdt>:
}

interrupt (WDT_VECTOR) INT_wdt( void )
{
    12ec:	00 13       	reti			

000012ee <INT_compa>:
}

interrupt (COMPARATORA_VECTOR) INT_compa( void )
{
    12ee:	00 13       	reti			

000012f0 <INT_timerb1>:
}

interrupt (TIMERB1_VECTOR) INT_timerb1( void )
{
    12f0:	00 13       	reti			

000012f2 <INT_timerb0>:
}

interrupt (TIMERB0_VECTOR) INT_timerb0( void )
{
    12f2:	00 13       	reti			

000012f4 <INT_nmi>:
}

interrupt (NMI_VECTOR) INT_nmi( void )
{
    12f4:	00 13       	reti			

000012f6 <Rsel_set>:
/* -----------------------------------------------------------------------
   Adjust the DCO resistor selection in streps until it is at rsel
   ----------------------------------------------------------------------- */
void Rsel_set( short rsel )
{
    12f6:	0e 4f       	mov	r15,	r14	;
  while( (BCSCTL1 & 0x07) != rsel )
    12f8:	5f 42 57 00 	mov.b	&0x0057,r15	;0x0057
    12fc:	3f f0 07 00 	and	#7,	r15	;#0x0007
    1300:	0f 9e       	cmp	r14,	r15	;
    1302:	0e 24       	jz	$+30     	;abs 0x1320
  {
    if( (BCSCTL1 & 0x07 ) > rsel )
    1304:	5f 42 57 00 	mov.b	&0x0057,r15	;0x0057
    1308:	3f f0 07 00 	and	#7,	r15	;#0x0007
    130c:	0e 9f       	cmp	r15,	r14	;
    130e:	09 34       	jge	$+20     	;abs 0x1322
    {
      BCSCTL1 -= 1;
    1310:	f2 53 57 00 	add.b	#-1,	&0x0057	;r3 As==11
    1314:	5f 42 57 00 	mov.b	&0x0057,r15	;0x0057
    1318:	3f f0 07 00 	and	#7,	r15	;#0x0007
    131c:	0f 9e       	cmp	r14,	r15	;
    131e:	f2 23       	jnz	$-26     	;abs 0x1304
    } else {
      BCSCTL1 += 1;
    }
  }
}
    1320:	30 41       	ret			
    1322:	d2 53 57 00 	inc.b	&0x0057		;
    1326:	f6 3f       	jmp	$-18     	;abs 0x1314

00001328 <dco_step>:


/* -----------------------------------------------------------------------
   Adjust the DCO using step method
   ----------------------------------------------------------------------- */
void dco_step( void )
{
    if( DCOCTL == DCO_MAX )
    1328:	f2 90 e2 ff 	cmp.b	#-30,	&0x0056	;#0xffe2
    132c:	56 00 
    132e:	1e 24       	jz	$+62     	;abs 0x136c
    {
      /* Increment Rsel */
      if( (BCSCTL1 & 0x07)  < 0x07 )
      {
        BCSCTL1 += 1;
        DCOCTL = 0x60;
      } 
    } else if( DCOCTL == DCO_MIN ) {
    1330:	f2 90 05 00 	cmp.b	#5,	&0x0056	;#0x0005
    1334:	56 00 
    1336:	0e 24       	jz	$+30     	;abs 0x1354
      /* Decrement Rsel */
      if( (BCSCTL1 & 0x07) > 0x00 )
      {
        BCSCTL1 -= 1;
        DCOCTL = 0x60;
      } 
    } else {
      if( VZC_2delta < FSET )
    1338:	b2 90 f4 00 	cmp	#244,	&0x0200	;#0x00f4
    133c:	00 02 
    133e:	03 2c       	jc	$+8      	;abs 0x1346
      {
        DCOCTL += 1;
    1340:	d2 53 56 00 	inc.b	&0x0056		;
      } else if( VZC_2delta > FSET ) {
        DCOCTL -= 1;
      }    
    }
}
    1344:	30 41       	ret			
    1346:	b2 90 f5 00 	cmp	#245,	&0x0200	;#0x00f5
    134a:	00 02 
    134c:	02 28       	jnc	$+6      	;abs 0x1352
    134e:	f2 53 56 00 	add.b	#-1,	&0x0056	;r3 As==11
    1352:	30 41       	ret			
    1354:	5f 42 57 00 	mov.b	&0x0057,r15	;0x0057
    1358:	3f f0 07 00 	and	#7,	r15	;#0x0007
    135c:	1f 93       	cmp	#1,	r15	;r3 As==01
    135e:	f9 3b       	jl	$-12     	;abs 0x1352
    1360:	f2 53 57 00 	add.b	#-1,	&0x0057	;r3 As==11
    1364:	f2 40 60 00 	mov.b	#96,	&0x0056	;#0x0060
    1368:	56 00 
    136a:	30 41       	ret			
    136c:	5f 42 57 00 	mov.b	&0x0057,r15	;0x0057
    1370:	3f f0 07 00 	and	#7,	r15	;#0x0007
    1374:	3f 90 07 00 	cmp	#7,	r15	;#0x0007
    1378:	ec 37       	jge	$-38     	;abs 0x1352
    137a:	d2 53 57 00 	inc.b	&0x0057		;
    137e:	f2 3f       	jmp	$-26     	;abs 0x1364

00001380 <ow_delay>:
void ow_delay( unsigned int d )
{
  unsigned int i;

  for( i=0; i<d; i++ )
    1380:	0e 43       	clr	r14		;
    1382:	0e 9f       	cmp	r15,	r14	;
    1384:	04 2c       	jc	$+10     	;abs 0x138e
  {
    asm("  nop");
    1386:	03 43       	nop			
    1388:	1e 53       	inc	r14		;
    138a:	0e 9f       	cmp	r15,	r14	;
    138c:	fc 2b       	jnc	$-6      	;abs 0x1386
  }
}
    138e:	30 41       	ret			

00001390 <ow_reset>:


/* -----------------------------------------------------------------------
   1-wire reset and presence detection

   return 0 no presence detected
   return 1 presence detected
   ----------------------------------------------------------------------- */
int ow_reset( void )
{
    1390:	0b 12       	push	r11		;
    1392:	0a 12       	push	r10		;
  int status;
  

  _DINT();
    1394:	32 c2       	dint			
  /* Pull the 1-wire bus low for 500uS */
  P1OUT &= ~0x02;
    1396:	e2 c3 21 00 	bic.b	#2,	&0x0021	;r3 As==10
  P1DIR |= 0x02;
    139a:	e2 d3 22 00 	bis.b	#2,	&0x0022	;r3 As==10
  
  ow_delay( D500US );
    139e:	3a 40 80 13 	mov	#4992,	r10	;#0x1380
    13a2:	3f 40 64 00 	mov	#100,	r15	;#0x0064
    13a6:	8a 12       	call	r10		;
  
  /* Allow resistor to pull it high */
  P1DIR &= ~0x02;
    13a8:	e2 c3 22 00 	bic.b	#2,	&0x0022	;r3 As==10

  /* Delay 100uS before testing for presence */
  ow_delay( D100US );
    13ac:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    13b0:	8a 12       	call	r10		;

  /* Grab the status of the bus */  
  status =  !(P1IN & 0x02) ;
    13b2:	5f 42 20 00 	mov.b	&0x0020,r15	;0x0020
    13b6:	4b 4f       	mov.b	r15,	r11	;
    13b8:	12 c3       	clrc			
    13ba:	0b 10       	rrc	r11		;
    13bc:	1b e3       	xor	#1,	r11	;r3 As==01
    13be:	1b f3       	and	#1,	r11	;r3 As==01
  
  /* Finish out the presence pulse time */
  ow_delay( D150US );
    13c0:	3f 40 1a 00 	mov	#26,	r15	;#0x001a
    13c4:	8a 12       	call	r10		;
  
  _EINT();
    13c6:	32 d2       	eint			
  return status;
}
    13c8:	0f 4b       	mov	r11,	r15	;
    13ca:	3a 41       	pop	r10		;
    13cc:	3b 41       	pop	r11		;
    13ce:	30 41       	ret			

000013d0 <ow_write>:



/* -----------------------------------------------------------------------
   Write a 1-wire byte
   ----------------------------------------------------------------------- */
void ow_write( unsigned char d )
{
    13d0:	0b 12       	push	r11		;
    13d2:	0a 12       	push	r10		;
    13d4:	09 12       	push	r9		;
    13d6:	4b 4f       	mov.b	r15,	r11	;
  unsigned int i;
  
  /* Output a 1 */
  _DINT();
    13d8:	32 c2       	dint			
  P1OUT |= 0x02;
    13da:	e2 d3 21 00 	bis.b	#2,	&0x0021	;r3 As==10
  P1DIR |= 0x02;
    13de:	e2 d3 22 00 	bis.b	#2,	&0x0022	;r3 As==10
  
  for(i=0;i<8;i++)
    13e2:	0a 43       	clr	r10		;
    13e4:	39 40 80 13 	mov	#4992,	r9	;#0x1380
  {
    if( d & 0x01 )
    13e8:	0f 4b       	mov	r11,	r15	;
    13ea:	1f f3       	and	#1,	r15	;r3 As==01
    13ec:	10 24       	jz	$+34     	;abs 0x140e
    {
      /* Write a 1 -- pull low for ~8uS (must be 1-15uS) */
      P1OUT &= ~0x02;
    13ee:	e2 c3 21 00 	bic.b	#2,	&0x0021	;r3 As==10
      asm("  nop");
    13f2:	03 43       	nop			
      asm("  nop");
    13f4:	03 43       	nop			
      asm("  nop");			/* About 8uS       	*/
    13f6:	03 43       	nop			
      P1OUT |= 0x02;                    /* Keep it high		*/
    13f8:	e2 d3 21 00 	bis.b	#2,	&0x0021	;r3 As==10
      ow_delay( D100US );
    13fc:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    1400:	89 12       	call	r9		;
    } else {
      /* Write a 0 */
      P1OUT &= ~0x02;
      ow_delay( D100US );
      P1OUT |= 0x02;      
      asm("  nop");
      asm("  nop");
    }
    d = d >> 1;
    1402:	12 c3       	clrc			
    1404:	4b 10       	rrc.b	r11		;
    1406:	1a 53       	inc	r10		;
    1408:	3a 92       	cmp	#8,	r10	;r2 As==11
    140a:	ee 2b       	jnc	$-34     	;abs 0x13e8
    140c:	0a 3c       	jmp	$+22     	;abs 0x1422
    140e:	e2 c3 21 00 	bic.b	#2,	&0x0021	;r3 As==10
    1412:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    1416:	89 12       	call	r9		;
    1418:	e2 d3 21 00 	bis.b	#2,	&0x0021	;r3 As==10
    141c:	03 43       	nop			
    141e:	03 43       	nop			
    1420:	f0 3f       	jmp	$-30     	;abs 0x1402
  }
  
  /* Let pullup pull data line high */
  P1DIR &= ~0x02;
    1422:	e2 c3 22 00 	bic.b	#2,	&0x0022	;r3 As==10

  _EINT();
    1426:	32 d2       	eint			
}
    1428:	39 41       	pop	r9		;
    142a:	3a 41       	pop	r10		;
    142c:	3b 41       	pop	r11		;
    142e:	30 41       	ret			

00001430 <ow_read>:


/* -----------------------------------------------------------------------
   Read a 1-wire byte
   ----------------------------------------------------------------------- */
unsigned char ow_read()
{
    1430:	0b 12       	push	r11		;
    1432:	0a 12       	push	r10		;
    1434:	09 12       	push	r9		;
  unsigned char d;
  unsigned int i;
  
  _DINT();
    1436:	32 c2       	dint			
  P1OUT |= 0x02;
    1438:	e2 d3 21 00 	bis.b	#2,	&0x0021	;r3 As==10
  P1DIR |= 0x02;
    143c:	e2 d3 22 00 	bis.b	#2,	&0x0022	;r3 As==10
  
  d = 0;
    1440:	4b 43       	clr.b	r11		;
  for(i=0;i<8;i++)
    1442:	0a 43       	clr	r10		;
    1444:	39 40 80 13 	mov	#4992,	r9	;#0x1380
  {
    P1OUT &= ~0x02;			/* Pull ow line low	*/
    1448:	e2 c3 21 00 	bic.b	#2,	&0x0021	;r3 As==10
    P1DIR |= 0x02;
    144c:	e2 d3 22 00 	bis.b	#2,	&0x0022	;r3 As==10
    asm("  nop");
    1450:	03 43       	nop			
    asm("  nop");
    1452:	03 43       	nop			
    asm("  nop");			/* About 8uS       	*/
    1454:	03 43       	nop			
    P1DIR &= ~0x02;			/* Let pullup pull	*/      
    1456:	e2 c3 22 00 	bic.b	#2,	&0x0022	;r3 As==10
  
    /* Delay for 20uS before sampling */
    ow_delay( 0 );
    145a:	0f 43       	clr	r15		;
    145c:	89 12       	call	r9		;
    
    d = d >> 1;
    145e:	12 c3       	clrc			
    1460:	4b 10       	rrc.b	r11		;
    if( P1IN & 0x02 )
    1462:	5f 42 20 00 	mov.b	&0x0020,r15	;0x0020
    1466:	2f f3       	and	#2,	r15	;r3 As==10
    1468:	09 24       	jz	$+20     	;abs 0x147c
    {
      d = d | 0x80;
    146a:	7b d0 80 ff 	bis.b	#-128,	r11	;#0xff80
    } else {
      d = d & 0x7F;
    }
    
    /* Delay to allow release */
    ow_delay( 5 );
    146e:	3f 40 05 00 	mov	#5,	r15	;#0x0005
    1472:	89 12       	call	r9		;
    1474:	1a 53       	inc	r10		;
    1476:	3a 92       	cmp	#8,	r10	;r2 As==11
    1478:	e7 2b       	jnc	$-48     	;abs 0x1448
    147a:	03 3c       	jmp	$+8      	;abs 0x1482
    147c:	7b f0 7f 00 	and.b	#127,	r11	;#0x007f
    1480:	f6 3f       	jmp	$-18     	;abs 0x146e
  }
    
  _EINT();
    1482:	32 d2       	eint			
  return d;
    1484:	4f 4b       	mov.b	r11,	r15	;
}
    1486:	39 41       	pop	r9		;
    1488:	3a 41       	pop	r10		;
    148a:	3b 41       	pop	r11		;
    148c:	30 41       	ret			

0000148e <ow_read_rom>:


/* -----------------------------------------------------------------------
   Read the serial number from a device
   ----------------------------------------------------------------------- */
void ow_read_rom( unsigned char *sn )
{
    148e:	0b 12       	push	r11		;
    1490:	0a 12       	push	r10		;
    1492:	09 12       	push	r9		;
    1494:	08 12       	push	r8		;
    1496:	0a 4f       	mov	r15,	r10	;
  unsigned int i;

  if( ow_reset() == 1 )
    1498:	38 40 90 13 	mov	#5008,	r8	;#0x1390
    149c:	88 12       	call	r8		;
    149e:	1f 93       	cmp	#1,	r15	;r3 As==01
    14a0:	11 20       	jnz	$+36     	;abs 0x14c4
  {
    /* Send the read ROM command */
    ow_write( 0x33 );
    14a2:	7f 40 33 00 	mov.b	#51,	r15	;#0x0033
    14a6:	b0 12 d0 13 	call	#5072		;#0x13d0
    
    for(i=0;i<8;i++)
    14aa:	0b 43       	clr	r11		;
    14ac:	39 40 30 14 	mov	#5168,	r9	;#0x1430
    {
      /* Read the serial number */
      sn[i] = ow_read();
    14b0:	89 12       	call	r9		;
    14b2:	4e 4f       	mov.b	r15,	r14	;
    14b4:	0f 4a       	mov	r10,	r15	;
    14b6:	0f 5b       	add	r11,	r15	;
    14b8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;
    14bc:	1b 53       	inc	r11		;
    14be:	3b 92       	cmp	#8,	r11	;r2 As==11
    14c0:	f7 2b       	jnc	$-16     	;abs 0x14b0
    }
    
    ow_reset();
    14c2:	88 12       	call	r8		;
  }
}
    14c4:	38 41       	pop	r8		;
    14c6:	39 41       	pop	r9		;
    14c8:	3a 41       	pop	r10		;
    14ca:	3b 41       	pop	r11		;
    14cc:	30 41       	ret			

000014ce <__stop_progExec__>:
    14ce:	0f 12       	push	r15		;
    14d0:	3f 41       	pop	r15		;

000014d2 <__stop_progLoop>:
    14d2:	02 df       	bis	r15,	r2	;
    14d4:	fe 3f       	jmp	$-2      	;abs 0x14d2
Disassembly of section .vectors:

0000ffe0 <InterruptVectors>:
    ffe0:	3a 11 ba 12 bc 12 be 12 c0 12 c2 12 e4 12 e6 12     :...............
    fff0:	e8 12 ea 12 ec 12 ee 12 f0 12 f2 12 f4 12 00 11     ................
